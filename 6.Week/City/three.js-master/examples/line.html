<!DOCTYPE html>
<html lang="en">
	<head>
	</head>
	<body>

		<script type="x-shader/x-vertex" id="vertexshader">

			varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

		
			uniform float time;
			varying vec2 vUv;

		
			void main() {

				vec2 position = vUv;
 
				float red = abs( sin( position.x  + time / 5.0 ) );
				float green = abs( sin( position.x + time / 4.0 ) );
				float blue = abs( sin( position.x + time / 3.0 ) );
				gl_FragColor = vec4( red, green, blue, 1.0 );

			}

		</script>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import { GUI } from './jsm/libs/dat.gui.module.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
			import { RenderPass } from './jsm/postprocessing/RenderPass.js';
			import { ShaderPass } from './jsm/postprocessing/ShaderPass.js';
			import { UnrealBloomPass } from './jsm/postprocessing/UnrealBloomPass.js';
			import { Line2 } from './jsm/lines/Line2.js';
			import { LineMaterial } from './jsm/lines/LineMaterial.js';
			import { LineGeometry } from './jsm/lines/LineGeometry.js';
			import { LineSegments2 } from './jsm/lines/LineSegments2.js';
			import { GeometryUtils } from './jsm/utils/GeometryUtils.js';
			var scene, camera, controls;
			var renderer;

			var params = {
				width:0.007
			};


			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.toneMapping = THREE.ReinhardToneMapping;
			document.body.appendChild( renderer.domElement );

			scene = new THREE.Scene();
            
			camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 200 );
			camera.position.set( 0, 0, 20 );
			camera.lookAt( 0, 0, 0 );

			controls = new OrbitControls( camera, renderer.domElement );
			controls.maxPolarAngle = Math.PI * 0.5;
			controls.minDistance = 1;
			controls.maxDistance = 100;
            controls.addEventListener( 'change', render );
			//scene.add( new THREE.AmbientLight( 0x404040 ) );

			var renderScene = new RenderPass( scene, camera );
            
			var basicComposer = new EffectComposer( renderer );
			basicComposer.renderToScreen = true;
			basicComposer.addPass( renderScene );

			var uniforms = {
				time: { value: 0.1 },
            };
			// var finalPass = new ShaderPass(
			// 	new THREE.ShaderMaterial( {
			// 		uniforms: uniforms,
			// 		vertexShader: document.getElementById( 'vertexshader' ).textContent,
			// 		fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
			// 		defines: {}
			// 	} ), "baseTexture"
			// );
			// finalPass.needsSwap = true;
			// basicComposer.addPass( finalPass );
			// var finalComposer = new EffectComposer( renderer );
			// finalComposer.addPass( renderScene );
			// finalComposer.addPass( finalPass );



			// var gui = new GUI();
				
            // var matLine = new LineMaterial( {

			// 		color: 0xff61f0,
			// 		linewidth: 0.01, // in pixels
			// 		vertexColors: THREE.VertexColors,
			// } );

            // var positions = []
            // var colors = []
            // positions.push(-5,5,0);
            // positions.push(5,0,0);
            // colors.push(256,61,0);
            // colors.push(60,251,0);

            // var geometry = new LineGeometry();
            // geometry.setPositions( positions );
            // geometry.setColors( colors );

            // var line = new Line2( geometry, matLine );
            // line.position.set(0,0,0);
            // scene.add(line);

            var planeGeometry = new THREE.PlaneGeometry(20,1);
            // var texture = new THREE.Texture();
            // var imgLoader = new THREE.ImageLoader();
            // imgLoader.load('http://localhost:8080/video/map.png',function(img)
            // {
            //     texture.image = img;
            //     texture.needsUpdate = true;
            // });
            var material = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
					defines: {}
				} );
            var mesh = new THREE.Mesh( planeGeometry,material );
            mesh.position.set(0, 0, 0);
            scene.add(mesh);
           

			// gui.add( params, 'exposure', 0.1, 1.0 ).step(0.01).onChange( function ( value ) {

			// 	renderer.toneMappingExposure = Math.pow( value, 4.0 );
			// 	render();

			// } );

			// gui.add( params, 'bloomThreshold', 0.0, 1.0 ).step(0.01).onChange( function ( value ) {

			// 	bloomPass.threshold = Number( value );
			// 	render();

			// } );

			// gui.add( params, 'bloomStrength', 0.0, 10.0 ).onChange( function ( value ) {

			// 	bloomPass.strength = Number( value );
			// 	render();

			// } );

			// gui.add( params, 'bloomRadius', 0.0, 1.0 ).step( 0.01 ).onChange( function ( value ) {

			// 	bloomPass.radius = Number( value );
			// 	render();

			// } );
			// gui.add( params, 'width', 0.001, 0.01 ).step(0.001).onChange( function ( val ) {
			// 	matLine.linewidth = val;
			// 	render();
			// } );

			window.onresize = function () {

				var width = window.innerWidth;
				var height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

				basicComposer.setSize( width, height );
				//finalComposer.setSize( width, height );

				render();

			};
			var clock = new THREE.Clock();

			function render() {
                requestAnimationFrame(render);
				uniforms.time.value+=clock.getDelta()*10;
                basicComposer.render();
                //finalComposer.render();
				//render();
			}
            render();
           

		</script>

	</body>

</html>
