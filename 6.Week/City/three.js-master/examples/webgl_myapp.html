<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - postprocessing - unreal bloom</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="container"></div>

		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - Bloom pass by <a href="http://eduperiment.com" target="_blank" rel="noopener">Prashant Sharma</a> and <a href="https://clara.io" target="_blank" rel="noopener">Ben Houston</a>
			<p>
				This Bloom Pass is inspired by the bloom pass of the Unreal Engine. It creates a mip map chain of bloom textures and blur them
				with different radii.<br /> Because of the weigted combination of mips, and since larger blurs are done on higher mips, this bloom
				is better in quality and performance.
			</p>
			Model: <a href="https://blog.sketchfab.com/art-spotlight-primary-ion-drive/" target="_blank" rel="noopener">Primary Ion Drive</a> by
			<a href="http://mjmurdock.com/" target="_blank" rel="noopener">Mike Murdock</a>, CC Attribution.
		</div>
		<!-- <script type="x-shader/x-fragment" id="fragmentShader">
			uniform sampler2D texture1;
			
			varying vec2 vUv;
		
			void main(void){
				gl_FragColor = texture2D( texture1, vUv);
			}
		</script>

		<script id="vertexShader" type="x-shader/x-vertex">
			varying vec2 vUv;
	
			void main() {
				vUv = uv;
				gl_Position =   projectionMatrix * 
								modelViewMatrix * 
								vec4(position,1.0);
			}
		</script> -->

		<script type="x-shader/x-vertex" id="vertexshader">

			varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform sampler2D baseTexture;
			uniform sampler2D bloomTexture;

			varying vec2 vUv;

			vec4 getTexture( sampler2D texelToLinearTexture ) {

				return mapTexelToLinear( texture2D( texelToLinearTexture , vUv ) );

			}

			void main() {

				gl_FragColor = ( getTexture( baseTexture ) + vec4( 1.0 ) * getTexture( bloomTexture ) );

			}

		</script>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import Stats from './jsm/libs/stats.module.js';
			import { GUI } from './jsm/libs/dat.gui.module.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
			import { RenderPass } from './jsm/postprocessing/RenderPass.js';
			import { UnrealBloomPass } from './jsm/postprocessing/UnrealBloomPass.js';
			import { Line2 } from './jsm/lines/Line2.js';
			import { LineMaterial } from './jsm/lines/LineMaterial.js';
			import { LineGeometry } from './jsm/lines/LineGeometry.js';
			import { LineSegments2 } from './jsm/lines/LineSegments2.js';
			import { GeometryUtils } from './jsm/utils/GeometryUtils.js';
			import {ShaderPass} from './jsm/postprocessing/ShaderPass.js';
			import {CopyShader} from './jsm/shaders/CopyShader.js';
			import {ClearPass} from './jsm/postprocessing/ClearPass.js'
			import {FocusShader} from './jsm/shaders/FocusShader.js';
			var scene, camera, controls, pointLight, stats;
			var composer, renderer, mixer;
			//var geometry, line, matLine;

			var params = {
				exposure: 1,
				bloomStrength: 1.5,
				bloomThreshold: 0,
				bloomRadius: 0,
				width:0.1
			};

			var clock = new THREE.Clock();
			var container = document.getElementById( 'container' );

			stats = new Stats();
			container.appendChild( stats.dom );

			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			//renderer.toneMapping = THREE.ReinhardToneMapping;
			
			container.appendChild( renderer.domElement );

			scene = new THREE.Scene();
			var scene1 = new THREE.Scene();

			camera = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 1, 1000 );
			camera.position.set( 100, 100, 0 );
			camera.lookAt({x:0,y:0,z:0})
			scene.add( camera );

			controls = new OrbitControls( camera, renderer.domElement );
			controls.maxPolarAngle = Math.PI * 0.5;
			controls.minDistance = 1;
			controls.maxDistance = 10;

			scene.add( new THREE.AmbientLight( 0x404040 ) );

			pointLight = new THREE.PointLight( 0xffffff, 1 );
			camera.add( pointLight );

			
			{
			// new GLTFLoader().load( 'models/gltf/PrimaryIonDrive.glb', function ( gltf ) {

			// 	var model = gltf.scene;

			// 	scene.add( model );

			// 	// Mesh contains self-intersecting semi-transparent faces, which display
			// 	// z-fighting unless depthWrite is disabled.
			// 	var core = model.getObjectByName( 'geo1_HoloFillDark_0' );
			// 	core.material.depthWrite = false;

			// 	mixer = new THREE.AnimationMixer( model );
			// 	var clip = gltf.animations[ 0 ];
			// 	mixer.clipAction( clip.optimize() ).play();

			// 	animate();

			// } );

			// var geometry = new THREE.Geometry();
			// geometry.vertices.push(
			// 	new THREE.Vector3(-100, 0, 100),
			// 	new THREE.Vector3(100, 0, -100)
			// );
			// geometry.colors.push(
			// 	new THREE.Color( 0xFF6100 ), 
			// 	new THREE.Color( 0xFF6100 )
			// )
			// var material = new THREE.LineBasicMaterial({ vertexColors: true});
			
			// var line = new THREE.Line(geometry, material);
			}
			var matLine = new LineMaterial( {

				color: 0xff61f0,
				linewidth: 0.001, // in pixels
				vertexColors: THREE.VertexColors,
				//resolution:  // to be set by renderer, eventually
				//dashed: false

			} );
			
			var positions = []
			var colors = []
			positions.push(-5,5,0);
			positions.push(5,0,0);
			positions.push(0,0,0);
			positions.push(0,5,0);
			//positions.push(10,-5,0);
			colors.push(256,61,0);
			colors.push(256,61,0);
			colors.push(256,61,0);
			colors.push(256,61,0);
			//colors.push(256,61,0);
			var geometry = new LineGeometry();
			geometry.setPositions( positions );
			geometry.setColors( colors );
			
			var line = new Line2( geometry, matLine );
			line.position.set(0,0,0);
			scene.add(line);

			var planeGeometry = new THREE.PlaneGeometry(12,8);
			//加载纹理
			var texture = new THREE.Texture();
			//var textureLoader = new THREE.TextureLoader();
			//加载图片
			var imgLoader = new THREE.ImageLoader();
			imgLoader.load('http://localhost:8080/video/map.png',function(img)
			{
				//将图片值赋于纹理
				texture.image = img;
				texture.needsUpdate = true;
			});
			// var uniforms = {
			// 	texture1: {
			// 		type: "t",
			// 		value: textureLoader.load('http://localhost:8080/video/map.jpg')
			// 	}
    		// };
			// uniforms.texture1.value.warpS = uniforms.texture1.value.warpT = THREE.RepeatWrapping;
			//var material = new THREE.ShaderMaterial({
			// 	uniforms : uniforms,
        	// 	vertexShader: document.getElementById( 'vertexShader' ).text,
        	// 	fragmentShader: document.getElementById( 'fragmentShader' ).text,
        	// 	side:THREE.DoubleSide
				
			//});
			//
			var material = new THREE.MeshBasicMaterial({map:texture});
    		var mesh = new THREE.Mesh( planeGeometry,material );
			mesh.position.set(0, 0, 0);
			scene.add(mesh);
    		scene1.add(mesh);
			// var planeGeometry = new THREE.PlaneGeometry(60,0.05);
			// var planeMaterial = new THREE.MeshLambertMaterial({color:0xFF6100});
			// var plane = new THREE.Mesh(planeGeometry, planeMaterial);
			// scene.add(plane)	

			let clearPass = new ClearPass()
			var renderScene = new RenderPass( scene, camera );
			//renderScene.clear = false;
			var renderScene1 = new RenderPass( scene1, camera );
			//renderScene1.needsSwap = true;
			renderScene1.clear = false;
			var bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
			bloomPass.threshold = params.bloomThreshold;
			bloomPass.strength = params.bloomStrength;
			bloomPass.radius = params.bloomRadius;
			
			var focusPass = new ShaderPass(FocusShader);
        	//focusPass.enabled = true; 

			let outputPass = new ShaderPass(CopyShader)
			//outputPass.clear = false;
         	outputPass.renderToScreen = true

			composer = new EffectComposer( renderer );
			//composer.renderToScreen = false;

			composer.addPass( clearPass );
			
			composer.addPass( renderScene );//线
			composer.addPass( bloomPass );
			composer.addPass( renderScene1 );//地图
			//composer.addPass( focusPass );
			composer.addPass( outputPass );
				
			var gui = new GUI();

			gui.add( params, 'exposure', 0.1, 1.0 ).step(0.001).onChange( function ( value ) {

				renderer.toneMappingExposure = Math.pow( value, 4.0 );

			} );

			gui.add( params, 'bloomThreshold', 0.0, 2.0 ).step(0.1).onChange( function ( value ) {

				bloomPass.threshold = Number( value );

			} );

			gui.add( params, 'bloomStrength', 0.0, 10.0 ).onChange( function ( value ) {

				bloomPass.strength = Number( value );

			} );

			gui.add( params, 'bloomRadius', 0.0, 2.0 ).step( 0.01 ).onChange( function ( value ) {

				bloomPass.radius = Number( value );

			} );
			gui.add( params, 'width', 0.001, 0.01 ).step(0.001).onChange( function ( val ) {

				matLine.linewidth = val;

			} );
			window.onresize = function () {

				var width = window.innerWidth;
				var height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );
				composer.setSize( width, height );

			};


			function animate() {

				requestAnimationFrame( animate );

				const delta = clock.getDelta();

				//mixer.update( delta );

				stats.update();
				
				composer.render();

			}
			animate();
		</script>

	</body>

</html>
