<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>Vertices For Geometry</title>
    <script src="../build/three.js"></script>
    <script src="./js/libs/stats.js"></script>
    <script src="./js/utils/SceneUtils.js"></script>
</head>
<body>

    <script type="x-shader/x-vertex" id="vertexshader">

        varying vec2 vUv;

        void main() {

            vUv = uv;

            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

        }

    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">

    
        uniform float time;
        varying vec2 vUv;

    
        void main() {

            vec2 position = vUv;

            float red = abs( sin( position.x  + time / 5.0 ) );
            float green = abs( sin( position.x + time / 4.0 ) );
            float blue = abs( sin( position.x + time / 3.0 ) );
            gl_FragColor = vec4( red, green, blue, 1.0 );

        }

    </script>
<script type="module">
    import { OrbitControls } from './jsm/controls/OrbitControls.js';
    import { GUI } from './jsm/libs/dat.gui.module.js';
    import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from './jsm/postprocessing/RenderPass.js';
    import { ShaderPass } from './jsm/postprocessing/ShaderPass.js';
    import { UnrealBloomPass } from './jsm/postprocessing/UnrealBloomPass.js';
    import { Line2 } from './jsm/lines/Line2.js';
    import { LineMaterial } from './jsm/lines/LineMaterial.js';
    import { LineGeometry } from './jsm/lines/LineGeometry.js';
    import { GeometryUtils } from './jsm/utils/GeometryUtils.js';
    let renderer, camera, scene, scene2;
    let controller;
    var uniforms =  {
		time: { value: 0.1 },
    };
    //let controls;
    let vertices, vertices2, vertices3, vertices4;
    let faces, faces2, faces3, faces4;
    let controlPoints = [];
    var geom, geom2, geom3, geom4;
    let mesh, mesh2, mesh3, mesh4;
    var matLine;
    var renderScene, bloomComposer, bloomComposer2, bloomPass, renderScene2;
    var params = {
        exposure: 1.5,
        bloomStrength: 2.3,
        bloomThreshold: 0.47,
        bloomRadius: 0.2,
        width:0.007
    };
    

    renderer = new THREE.WebGLRenderer({
            antialias: true
        });//定义渲染器
        renderer.setSize(window.innerWidth, window.innerHeight);//设置渲染的宽度和高度
        document.body.appendChild(renderer.domElement);//将渲染器加在html中的div里面
        renderer.setClearColor(0x000000, 1.0);//渲染的颜色设置
        // renderer.shadowMapEnabled = true;//开启阴影，默认是关闭的，太影响性能
        // renderer.shadowMapType = THREE.PCFSoftShadowMap;//阴影的一个类型
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);//perspective是透视摄像机，这种摄像机看上去画面有3D效果
        //摄像机的位置
        camera.position.x = 10;
        camera.position.y = 15;
        camera.position.z = 15;
        camera.up.x = 0;
        camera.up.y = 1;//摄像机的上方向是Y轴
        camera.up.z = 0;
        camera.lookAt(0, 0, 0);//摄像机对焦的位置
        //这三个参数共同作用才能决定画面
        
        scene = new THREE.Scene();
        scene2 = new THREE.Scene();

        let light = new THREE.SpotLight(0xffffff, 1.0, 0);//点光源
        light.position.set(-40, 60, -10);
        // light.castShadow = true;//开启阴影
        // light.shadowMapWidth = 8192;//阴影的分辨率，可以不设置对比看效果
        // light.shadowMapHeight = 8192;
        scene.add(light);
        scene2.add(light);
        light = new THREE.AmbientLight(0xeeeeee, 0.2);//环境光，如果不加，点光源照不到的地方就完全是黑色的
        scene.add(light);
        scene2.add(light);
        controller = new OrbitControls(camera, renderer.domElement);
        controller.target = new THREE.Vector3(0, 0, 0);
        var axesHelper = new THREE.AxesHelper( 150 );
        axesHelper.position.x = 0
        axesHelper.position.y = 0
        scene.add( axesHelper );

        vertices = [
            new THREE.Vector3(1, 5, 1),
            new THREE.Vector3(1, 5, -1),
            new THREE.Vector3(1, 0, 1),
            new THREE.Vector3(1, 0, -1),
            new THREE.Vector3(-1, 5, -1),
            new THREE.Vector3(-1, 5, -1),
            new THREE.Vector3(-1, 0, -1),
            new THREE.Vector3(-1, 0, 1)
        ];//顶点坐标，一共8个顶点
        faces = [
             new THREE.Face3(0, 2, 1),
             new THREE.Face3(2, 3, 1),
             new THREE.Face3(4, 6, 5),
             new THREE.Face3(6, 7, 5),
             new THREE.Face3(4, 5, 1),
             new THREE.Face3(5, 0, 1),
             new THREE.Face3(7, 6, 2),
             new THREE.Face3(6, 3, 2),
             new THREE.Face3(5, 7, 0),
             new THREE.Face3(7, 2, 0),
             new THREE.Face3(1, 3, 4),
             new THREE.Face3(3, 6, 4),
        ];//顶点索引，每一个面都会根据顶点索引的顺序去绘制线条
        geom = new THREE.Geometry();
        geom.vertices = vertices;
        geom.faces = faces;
        geom.computeFaceNormals();//计算法向量，会对光照产生影响
        var texture = new THREE.Texture();
        var imgLoader = new THREE.ImageLoader();
        imgLoader.load('http://localhost:8080/video/ny1.jpg',function(img)
        {
            texture.image = img;
            texture.needsUpdate = true;
        });
        var t0 = new THREE.Vector2(0,0);//图片左下角
        var t1 = new THREE.Vector2(0,0.5);
        var t2 = new THREE.Vector2(0,0.75);
        var t3 = new THREE.Vector2(0,1);

        var t4 = new THREE.Vector2(0,0);
        var t5 = new THREE.Vector2(0.5,0);
        var t6 = new THREE.Vector2(0.75,0);
        var t7 = new THREE.Vector2(1,0);

        var t9 = new THREE.Vector2(0.5,0.5);
        var t10 = new THREE.Vector2(0.5,0.75);
        var t11 = new THREE.Vector2(0.5,1);
        var t12 = new THREE.Vector2(0.5,0.125);
        var t13 = new THREE.Vector2(0.75,0);
        var t14 = new THREE.Vector2(1,1);

        var uv1 = [t0,t3,t5];//选中图片一个三角区域像素——映射到三角面1
        var uv2 = [t3,t11,t5];//选中图片一个三角区域像素——映射到三角面2
        var uv3 = [t5,t12,t13];
        geom.faceVertexUvs[0].push(uv1,uv2,uv1,uv2,uv1,uv3,uv1,uv2,uv1,uv2,uv1,uv2);
        //geom.faceVertexUvs[0] = []

        //geom.faceVertexUvs[1].push(uv2,uv1);
        //两个材质放在一起使用
        let materials = 
            new THREE.MeshLambertMaterial({map:texture})
            //new THREE.MeshLambertMaterial({opacity: 0.3, transparent: false, map:texture}),//透明度更改
            //new THREE.MeshBasicMaterial({color: 0x000000, wireframe: true})//线条材质，让观察更直观一点
        ;


        //创建多材质对象，要引入SceneUtils.js文件，如果只有一个材质就不需要这个函数
        mesh = new THREE.Mesh(geom, materials);
        mesh.children.forEach(function (e) {
            e.castShadow = true
        });
        scene.add(mesh)

        
        var material = new THREE.ShaderMaterial( {
            uniforms: uniforms,
            vertexShader: document.getElementById( 'vertexshader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
            defines: {}
        } );
        //var material = new THREE.LineBasicMaterial({color:0xff6100});
        
       
        for(var i = 0; i < vertices.length; ++i){
            for(var j = 0; j < vertices.length; ++j){
                var geometry = new THREE.Geometry();
                geometry.vertices = []
                geometry.vertices.push(vertices[i]);
                geometry.vertices.push(vertices[j]);
                var line = new THREE.Line(geometry,material);
                scene.add(line);
            }
           
        }
        



        vertices2 = [
            new THREE.Vector3(2.5, 5, 3.5),
            new THREE.Vector3(4.5, 5, 0),
            new THREE.Vector3(3, 0, 3),
            new THREE.Vector3(6, 0, 0),
            new THREE.Vector3(0, 5, 0),
            new THREE.Vector3(-2, 5, 3),
            new THREE.Vector3(-3, 0, 0),
            new THREE.Vector3(0, 0, 3)
        ];//顶点坐标，一共8个顶点
        
        geom2 = new THREE.Geometry();
        geom2.vertices = vertices2;
        geom2.faces = faces;
        geom2.computeFaceNormals();//计算法向量，会对光照产生影响

        var uv1 = [t0,t3,t5];//选中图片一个三角区域像素——映射到三角面1
        var uv2 = [t3,t11,t5];//选中图片一个三角区域像素——映射到三角面2
        var uv3 = [t5,t12,t13];
        geom2.faceVertexUvs[0].push(uv1,uv2,uv1,uv2,uv3,uv3,uv1,uv2,uv1,uv2,uv1,uv2);



        //创建多材质对象，要引入SceneUtils.js文件，如果只有一个材质就不需要这个函数
        mesh2 = new THREE.Mesh(geom2, materials);
        mesh2.children.forEach(function (e) {
            e.castShadow = true
        });
        mesh2.translateX(2*4+3);
        scene.add(mesh2)
       
       
        for(var i = 0; i < vertices2.length; ++i){
            for(var j = 0; j < vertices2.length; ++j){
                var geometry = new THREE.Geometry();
                geometry.vertices = []
                geometry.vertices.push(vertices2[i]);
                geometry.vertices.push(vertices2[j]);
                var line = new THREE.Line(geometry,material);
                line.translateX(2*4+3);
                scene.add(line);
            }
           
        }


        vertices3 = [
            new THREE.Vector3(3, 5, 3),
            new THREE.Vector3(3, 5, 0),
            new THREE.Vector3(3, 0, 3),
            new THREE.Vector3(5, 0, 0),
            new THREE.Vector3(-2, 5, 0),
            new THREE.Vector3(0, 7, 3),
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, 3)
        ];//顶点坐标，一共8个顶点
        
        geom3 = new THREE.Geometry();
        geom3.vertices = vertices3;
        geom3.faces = faces;
        geom3.computeFaceNormals();//计算法向量，会对光照产生影响

        var uv1 = [t0,t3,t5];//选中图片一个三角区域像素——映射到三角面1
        var uv2 = [t3,t11,t5];//选中图片一个三角区域像素——映射到三角面2
        var uv3 = [t5,t12,t13];
        geom3.faceVertexUvs[0].push(uv1,uv2,uv1,uv2,uv3,uv3,uv1,uv2,uv1,uv2,uv1,uv2);

        //创建多材质对象，要引入SceneUtils.js文件，如果只有一个材质就不需要这个函数
        mesh3 = new THREE.Mesh(geom3, materials);
        mesh3.children.forEach(function (e) {
            e.castShadow = true
        });
        mesh3.translateZ(-2*8);
        scene.add(mesh3)
       

        //var material = new THREE.LineBasicMaterial({color:0xff6100});
        
       
        for(var i = 0; i < vertices3.length; ++i){
            for(var j = 0; j < vertices3.length; ++j){
                var geometry = new THREE.Geometry();
                geometry.vertices = []
                geometry.vertices.push(vertices3[i]);
                geometry.vertices.push(vertices3[j]);
                var line = new THREE.Line(geometry,material);
                line.translateZ(-2*8);
                scene.add(line);
            }
           
        }


        vertices4 = [
            new THREE.Vector3(3, 5, 3),
            new THREE.Vector3(3, 5, 0),
            new THREE.Vector3(3, 0, 3),
            new THREE.Vector3(3, 0, 0),
            new THREE.Vector3(0, 5, 0),
            new THREE.Vector3(0, 5, 3),
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, 3)
        ];//顶点坐标，一共8个顶点
        
        geom4 = new THREE.Geometry();
        geom4.vertices = vertices4;
        geom4.faces = faces;
        geom4.computeFaceNormals();//计算法向量，会对光照产生影响

        var uv1 = [t0,t3,t5];//选中图片一个三角区域像素——映射到三角面1
        var uv2 = [t3,t11,t5];//选中图片一个三角区域像素——映射到三角面2
        var uv3 = [t5,t12,t13];
        geom4.faceVertexUvs[0].push(uv1,uv2,uv1,uv2,uv3,uv3,uv1,uv2,uv1,uv2,uv1,uv2);

        //创建多材质对象，要引入SceneUtils.js文件，如果只有一个材质就不需要这个函数
        mesh4 = new THREE.Mesh(geom4, materials);
        mesh4.children.forEach(function (e) {
            e.castShadow = true
        });
        mesh4.translateX(2*4+3)
        mesh4.translateZ(-2*8);
        scene.add(mesh4)
       

        //var material = new THREE.LineBasicMaterial({color:0xff6100});
        
       
        for(var i = 0; i < vertices4.length; ++i){
            for(var j = 0; j < vertices4.length; ++j){
                var geometry = new THREE.Geometry();
                geometry.vertices = []
                geometry.vertices.push(vertices4[i]);
                geometry.vertices.push(vertices4[j]);
                var line = new THREE.Line(geometry,material);
                line.translateX(2*4+3)
                line.translateZ(-2*8);
                scene.add(line);
            }
           
        }

        // var planeGeometry = new THREE.PlaneGeometry(40,1);
        // var material =new THREE.MeshLambertMaterial({
        //     color:0xff6100,//三角面颜色
        //     side:THREE.DoubleSide//两面可见
        // });
        // var mesh = new THREE.Mesh( planeGeometry,material );
        // mesh.position.set(0, 0, -8);
        // mesh.rotation.x += 1.5;
        // scene.add(mesh);

        // var planeGeometry2 = new THREE.PlaneGeometry(40,1);

        // var mesh2 = new THREE.Mesh( planeGeometry2,material );
        // mesh2.position.set(0, 0, -8);
        // mesh2.rotation.x += 1.5;
        // mesh2.rotation.z += 1.5;
        // scene.add(mesh2);

        matLine = new LineMaterial( {
            color: 0xff61f0,
            linewidth: 0.01, // in pixels
            vertexColors: THREE.VertexColors,
        } );

        var positions = []
        var colors = []
        positions.push(-1, 0, -2);
        positions.push(2, 0, 0);
        
        colors.push(256,61,0);
        colors.push(256,61,0);

        var geometry = new LineGeometry();
        geometry.setPositions( positions );
        geometry.setColors( colors );

        var line = new Line2( geometry, matLine );
        line.scale.set(1,1,1)
        scene.add(line);

        // line.translateX(Math.random()*4+3);
        // line.translateZ(Math.random()*4+3);
        renderScene = new RenderPass( scene, camera );
        // renderScene2 = new RenderPass( scene2, camera );
        bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), params.bloomStrength, params.bloomRadius, params.bloomThreshold );
        bloomPass.threshold = params.bloomThreshold;
        bloomPass.strength = params.bloomStrength;
        bloomPass.radius = params.bloomRadius;

        bloomComposer = new EffectComposer( renderer );
        bloomComposer.renderToScreen = true;
        bloomComposer.addPass( renderScene );
        bloomComposer.addPass( bloomPass );

        //initDat();
        var controls = {
            uv1: 0.5,
            uv2: 0.5,
            uv3: 0.5,
            uv4: 0.5,
            uv5: 0.5,
            uv6: 0.5
        };
        
        var gui = new GUI();
        gui.add(controls,'uv1', 0, 1).onChange(function (e) {
            geom2.faceVertexUvs[0][5][0].x = e;
            geom2.uvsNeedUpdate = true;
        });
        gui.add(controls,'uv2', 0, 1).onChange(function (e) {
            geom2.faceVertexUvs[0][5][0].y = e;
            geom2.uvsNeedUpdate = true
        });
        gui.add(controls,'uv3', 0, 1).onChange(function (e) {
            geom2.faceVertexUvs[0][5][1].x = e;
            geom2.uvsNeedUpdate = true
        });
        gui.add(controls,'uv4', 0, 1).onChange(function (e) {
            geom2.faceVertexUvs[0][5][1].y = e;
            geom2.uvsNeedUpdate = true
        });
        gui.add(controls,'uv5', 0, 1).onChange(function (e) {
            geom2.faceVertexUvs[0][5][2].x = e;
            geom2.uvsNeedUpdate = true
        });
        gui.add(controls,'uv6', 0, 1).onChange(function (e) {
            geom2.faceVertexUvs[0][5][2].y = e;
            geom2.uvsNeedUpdate = true
        });
        gui.add( params, 'exposure', 0.1, 3.0 ).step(0.1).onChange( function ( value ) {
            renderer.toneMappingExposure = Math.pow( value, 4.0 );
        } );

        gui.add( params, 'bloomThreshold', 0.0, 1.0 ).step(0.01).onChange( function ( value ) {
            bloomPass.threshold = Number( value );
        } );

        gui.add( params, 'bloomStrength', 0.0, 10.0 ).onChange( function ( value ) {
            bloomPass.strength = Number( value );
        } );

        gui.add( params, 'bloomRadius', 0.0, 1.0 ).step( 0.01 ).onChange( function ( value ) {
            bloomPass.radius = Number( value );
        } );

        gui.add( params, 'width', 0.001, 0.01 ).step(0.001).onChange( function ( val ) {
            matLine.linewidth = val;
        } );

    //动画
    var clock = new THREE.Clock();

    function render() {
        // //stats.update();
        // // for (let i = 0; i < 8; i++) {
        // //     console.log(mesh);
        // //     mesh.geometry.vertices[i].set(controlPoints[i].x, controlPoints[i].y, controlPoints[i].z);
        // //     mesh.geometry.verticesNeedUpdate = true;
        // //     mesh.geometry.computeFaceNormals();
        // // }
        // let vertices = [];
        // for (let i = 0; i < 8; i++) {
        //     vertices.push(new THREE.Vector3(controlPoints[i].x, controlPoints[i].y, controlPoints[i].z));
        // }
        // mesh.children.forEach(function (e) {
        //     e.geometry.vertices = vertices;
        //     e.geometry.verticesNeedUpdate = true;//通知顶点更新
        //     e.geometry.elementsNeedUpdate = true;//特别重要，通知线条连接方式更新
        //     e.geometry.computeFaceNormals();
        // });
        uniforms.time.value+=clock.getDelta()*10;
        requestAnimationFrame(render);
        bloomComposer.render();
        //bloomComposer2.render();
        // renderer.autoClear = true;
        // renderer.render(scene2, camera);
    }
    // //主函数
    // function threeStart() {
    //     initThree();
    //     //building();
    //     line();
        
        // bloomComposer2 = new EffectComposer( renderer );
        // bloomComposer2.renderToScreen = true;
        // bloomComposer2.addPass( renderScene2 );
        // bloomComposer2.addPass( bloomPass );

    //     initDat()
        render();
    // }
    // threeStart()
</script>
</body>
</html>
