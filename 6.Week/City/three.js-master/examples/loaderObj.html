<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>LoadObj</title>
    <style>
    </style>
    <script src="../build/three.js"></script>
    <script src="./js/libs/dat.gui.min.js"></script>
    <script src="./js/libs/stats.min.js"></script>
    <script src="./js/loaders/OBJLoader.js"></script>
    <script src="./js/loaders/MTLLoader.js"></script>
</head>
<body>
    <script type="x-shader/x-vertex" id="vertexshader">

        varying vec2 vUv;

        void main() {

            vUv = uv;

            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

        }

    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">

    
        uniform float time;
        varying vec2 vUv;

    
        void main() {

            vec2 position = vUv;

            float red = abs( sin( position.x  + time / 5.0 ) );
            float green = abs( sin( position.x + time / 4.0 ) );
            float blue = abs( sin( position.x + time / 3.0 ) );
            gl_FragColor = vec4( red, green, blue, 1.0 );

        }

    </script>

<script type="module">
    import { OrbitControls } from './jsm/controls/OrbitControls.js';
    import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from './jsm/postprocessing/RenderPass.js';
    import { ShaderPass } from './jsm/postprocessing/ShaderPass.js';
    import { UnrealBloomPass } from './jsm/postprocessing/UnrealBloomPass.js';
    import { Line2 } from './jsm/lines/Line2.js';
    import { LineMaterial } from './jsm/lines/LineMaterial.js';
    import { LineGeometry } from './jsm/lines/LineGeometry.js';
    import { LineSegments2 } from './jsm/lines/LineSegments2.js';
    import { GeometryUtils } from './jsm/utils/GeometryUtils.js';

    var scene, camera, renderer, controls, guiControls;
    var renderScene, bloomComposer, bloomPass;
    var matLine,uniforms;
    var texture_up;


    var stats = initStats();
    var params = {
        exposure: 1.5,
        bloomStrength: 2.3,
        bloomThreshold: 0.47,
        bloomRadius: 0.2,
        width:0.007
	};
    /* 场景 */
    function initScene() {

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

    }

    /* 相机 */
    function initCamera() {

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100000);
        camera.position.set(-7377, 51, -1601);
        camera.lookAt(-7377, 56, -1755)
    }

    /* 渲染器 */
    function initRender() {

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);

        document.body.appendChild(renderer.domElement);

    }

    /* 灯光 */
    function initLight() {

        scene.add(new THREE.AmbientLight(0xffffff));

        var spotLight1 = new THREE.SpotLight(0xffffff);
        spotLight1.position.set(-400, -400, -400);

        var spotLight2 = new THREE.SpotLight(0xffffff);
        spotLight2.position.set(400, 400, 400);

        scene.add(spotLight1);
        scene.add(spotLight2);

    }

    /* 控制器 */
    function initControls() {

        /* 地图控件 */
        controls = new OrbitControls(camera, renderer.domElement);

        /* 属性参数 */

    }

    /* 调试插件 */
    function initGui() {

        guiControls = new function () {


        };

        var gui = new dat.GUI();
        gui.add( params, 'exposure', 0.1, 3.0 ).step(0.1).onChange( function ( value ) {

            renderer.toneMappingExposure = Math.pow( value, 4.0 );
            render();

        } );

        gui.add( params, 'bloomThreshold', 0.0, 1.0 ).step(0.01).onChange( function ( value ) {

            bloomPass.threshold = Number( value );
            render();

        } );

        gui.add( params, 'bloomStrength', 0.0, 10.0 ).onChange( function ( value ) {

            bloomPass.strength = Number( value );
            render();

        } );

        gui.add( params, 'bloomRadius', 0.0, 1.0 ).step( 0.01 ).onChange( function ( value ) {

            bloomPass.radius = Number( value );
            render();

        } );

        gui.add( params, 'width', 0.001, 0.01 ).step(0.001).onChange( function ( val ) {
        	matLine.linewidth = val;
        	render();
        } );
    }

    /* 场景中的内容 */
    function initContent() {

        var OBJLoader = new THREE.OBJLoader();//obj加载器
        var MTLLoader = new THREE.MTLLoader();//材质文件加载器
        MTLLoader.load('http://localhost:8080/video/ny3.mtl', function(materials) {
            // 返回一个包含材质的对象MaterialCreator
            console.log(materials);
            //obj的模型会和MaterialCreator包含的材质对应起来
            OBJLoader.setMaterials(materials);
            OBJLoader.load('http://localhost:8080/video/ny3.obj', function(obj) {
                console.log(obj);
                obj.scale.set(1, 1, 1); //放大obj组对象
                // obj.position.x = -7700;
                // obj.position.y = -500;
                // obj.position.z = -2500;
                scene.add(obj);//返回的组对象插入场景中
            })
        })
        
        var planeGeometry = new THREE.PlaneGeometry(20,15);
        var texture = new THREE.Texture();
        var imgLoader = new THREE.ImageLoader();
        imgLoader.load('http://localhost:8080/video/map.png',function(img)
        {
            texture.image = img;
            texture.needsUpdate = true;
        });
        var material = new THREE.MeshBasicMaterial({map:texture});
        var mesh = new THREE.Mesh( planeGeometry,material );
        mesh.position.set(-7377, 51, -1501);
        scene.add(mesh);

        matLine = new LineMaterial( {
            color: 0xff61f0,
            linewidth: 0.01, // in pixels
            vertexColors: THREE.VertexColors,
        } );

        var positions = []
        var colors = []
        positions.push(-7377, 51, -1601);
        positions.push(-7377, -10, -1601);
        positions.push(-7320, -51, -1601);
        positions.push(-7320, 0, -1601);

        colors.push(256,61,0);
        colors.push(256,61,0);
        colors.push(256,61,0);
        colors.push(256,61,0);

        var geometry = new LineGeometry();
        geometry.setPositions( positions );
        geometry.setColors( colors );

        var line = new Line2( geometry, matLine );
        line.position.set(0,0,0);
        scene.add(line);

        uniforms = {
			time: { value: 0.1 },
        };

        var planeGeometry = new THREE.PlaneGeometry(2000,10);
        var material = new THREE.ShaderMaterial( {
                uniforms: uniforms,
                vertexShader: document.getElementById( 'vertexshader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
                defines: {}
            } );
        var mesh = new THREE.Mesh( planeGeometry,material );
        mesh.position.set(-7380, 20, -1250);
        scene.add(mesh);
        var axesHelper = new THREE.AxesHelper( 15000 );

        scene.add(axesHelper)
        renderScene = new RenderPass( scene, camera );
        bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), params.bloomStrength, params.bloomRadius, params.bloomThreshold );
        bloomPass.threshold = params.bloomThreshold;
        bloomPass.strength = params.bloomStrength;
        bloomPass.radius = params.bloomRadius;

        bloomComposer = new EffectComposer( renderer );
        bloomComposer.renderToScreen = true;
        bloomComposer.addPass( renderScene );
        bloomComposer.addPass( bloomPass );

        
    }


    /* 性能插件 */
    function initStats() {

        var stats = new Stats();

        document.body.appendChild(stats.domElement);

        return stats;

    }

    /* 窗口变动触发 */
    function onWindowResize() {
       
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    /* 数据更新 */
    function update() {

        stats.update();
        controls.update();

        // 设置纹理偏移
        // texture_left.offset.x -= 0.02;
        //texture_up.offset.y -= 0.008;


    }

    /* 初始化 */
    function init() {

        initScene();
        initCamera();
        initRender();
        initLight();
        initControls();
        initContent();
        initGui();
        /* 监听事件 */
        window.addEventListener('resize', onWindowResize, false);

    }
    var clock = new THREE.Clock();
    /* 循环渲染 */
    function render() {
        //camera.position.set(-7377, 51, -1501);
        requestAnimationFrame(render);
        bloomComposer.render();
        update();
        uniforms.time.value+=clock.getDelta()*10;
        // console.log("position")
        // console.log(camera.position);
        // console.log("rotation")
        // console.log(camera.rotation);

    }

    /* 初始加载 */
    (function () {
        init();
        render();
    })();

</script>
</body>
</html>

