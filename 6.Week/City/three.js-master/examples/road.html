<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>纹理offset偏移</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* 溢出隐藏 */
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            color: rgb(240, 234, 234);
            font-size: 20px;
            margin-top: -30px;
            margin-left: -40px;
        }
    </style>
    <script src="../build/three.js"></script>
    <script src="./js/libs/dat.gui.min.js"></script>
    <script src="./js/libs/stats.min.js"></script>
    <script src="./js/loaders/GLTFLoader.js"></script>
</head>
<body>
<p id="loading">loading......</p>
<script type="module">
    import { OrbitControls } from './jsm/controls/OrbitControls.js';
    import { FBXLoader } from './jsm/loaders/FBXLoader.js';
    import { MTLLoader } from './jsm/loaders/MTLLoader.js';
    import { OBJLoader } from './jsm/loaders/OBJLoader.js';
    var scene, camera, renderer, controls, guiControls;
    var cubeMesh1, cubeMesh2, cubeMesh3;
    var stats = initStats();
    var materialShader;
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2(),INTERSECTED;
    /* 场景 */
    function initScene() {

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);

    }

    /* 相机 */
    function initCamera() {

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 0, -300);
        camera.lookAt(new THREE.Vector3(0, 0, 0));

    }

    /* 渲染器 */
    function initRender() {

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);

        document.body.appendChild(renderer.domElement);

    }

    /* 灯光 */
    function initLight() {

        scene.add(new THREE.AmbientLight(0x0c0c0c));

        var spotLight1 = new THREE.SpotLight(0xffffff);
        spotLight1.position.set(-400, -400, -400);

        var spotLight2 = new THREE.SpotLight(0xffffff);
        spotLight2.position.set(400, 400, 400);

        scene.add(spotLight1);
        scene.add(spotLight2);

    }

    /* 控制器 */
    function initControls() {

        /* 地图控件 */
        controls = new OrbitControls(camera, renderer.domElement);

        /* 属性参数 */

    }

    /* 调试插件 */
    function initGui() {

        guiControls = new function () {


        };

        var gui = new dat.GUI();


    }



    /* 场景中的内容 */
    // var texture_left;
    var texture_up;
	var mixers = [];
	var clock = new THREE.Clock();
    function initContent() {

        // texture_left = new THREE.TextureLoader().load('http://localhost:8080/video/right.png');
        // texture_up = new THREE.TextureLoader().load('http://localhost:8080/video/ny1.png');
        // console.log(CheckImgExists('http://localhost:8080/video/ny1.png'));
        // texture_up = new THREE.TextureLoader().load('http://localhost:8080/video/rright.png');
        // console.log(texture_up);
        // texture_left.wrapS = THREE.RepeatWrapping;
        // texture_left.wrapT = THREE.RepeatWrapping;

        // texture_up.wrapS = THREE.RepeatWrapping;
        // texture_up.wrapT = THREE.RepeatWrapping;

        // texture_left.repeat.x = 10;
        // texture_left.repeat.y =1;

        //texture_up.repeat.x = 20;
        //texture_up.repeat.y = 2;

        // var planeGeometry = new THREE.PlaneGeometry(30, 400);

        // var plane_left = new THREE.MeshBasicMaterial();
        // plane_left.color = new THREE.Color(0x00ff00);
        // plane_left.map = texture_left;
        // plane_left.transparent = true;
        // plane_left.side = THREE.DoubleSide;

        // var plane_up = new THREE.MeshBasicMaterial();
        // plane_up.color = new THREE.Color(0xffffff);
        // plane_up.map = texture_up;
        // plane_up.transparent = true;
        // plane_up.side = THREE.DoubleSide;

        // // var plane_left = new THREE.Mesh(planeGeometry, plane_left);
        // // plane_left.translateY(10);
        // // scene.add(plane_left);

        // var plane_up = new THREE.Mesh(planeGeometry, plane_up);
        // plane_up.translateY(-10);
        // scene.add(plane_up);
        
        var ccc = new THREE.Color(0xff0000);
        // removeLoading();
        const gltfmaterial = new THREE.ShaderMaterial({
				// transparent: false,//注意这里一定要设置基础材质的透明度为true
				// opacity: 0.5,
				// blending: THREE.AdditiveBlending,
				// blendDstAlpha: 1.0,
				// blendSrcAlpha: 1.0,
                
				uniforms: {
					// scale: {value: 0.0},
					// rate: {value: 0.0},
					// heightRadius: {type: 'f', value: height/2},
                    // customPoint.z < 0.5 || customPoint.z>-0.5 || 
					redColor: {type: 'f', value: ccc.r},
					greenColor: {type: 'f', value: ccc.g},
					blueColor: {type: 'f', value: ccc.b},
				},

				vertexShader:
					"       varying vec4 customPoint;\n" +
					"        void main() {\n" +
					"            vec4 outputPoint= projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n" +
					"            customPoint = vec4( position, 1.0 );\n" +
					"            gl_Position = outputPoint;\n" +
					"        }",

				fragmentShader:

					"        varying vec4 customPoint;\n" +
                    "        uniform float redColor;\n" +
                    "        uniform float greenColor;\n" +
                    "        uniform float blueColor;\n" +
					"        void main() {\n" +
					"            float semi = redColor > greenColor?redColor:greenColor;\n" +
                    "            float max = blueColor > semi?blueColor:semi;\n" +
                    "            if(customPoint.x > -0.01||customPoint.x < 0.01){\n" +
                    "               gl_FragColor = vec4(sin(2.0-abs(customPoint.z))*redColor,sin(2.0-abs(customPoint.z))*greenColor, sin(2.0-abs(customPoint.z))*blueColor, 0.7);\n" +
                    "            }\n"+
                    "            else{\n"+
                    "               gl_FragColor = vec4(redColor,greenColor, blueColor, 0.7);\n" +     
                    "            }\n"+
					"        }"

        });

        var material = new THREE.MeshNormalMaterial();
        material.onBeforeCompile = function ( shader ) {

            shader.uniforms.time = { value: 0 };

            shader.vertexShader = 'uniform float time;\n' + shader.vertexShader;
            shader.vertexShader = shader.vertexShader.replace(
                '#include <begin_vertex>',
                [
                    'float theta = sin( time + position.y ) / 2.0;',
                    'float c = cos( theta );',
                    'float s = sin( theta );',
                    'mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );',
                    'vec3 transformed = vec3( position ) * m;',
                    'vNormal = vNormal * m;'
                ].join( '\n' )
            );

            materialShader = shader;

        };

        
        var loader = new THREE.GLTFLoader();
        //'http://localhost:8080/video/untitledjiaozhui.gltf'
        
       //'http://localhost:8080/video/zhuizi.glb'
       // 'models/gltf/LeePerrySmith/LeePerrySmith.glb'
       // 'http://localhost:8080/video/renwutouxiangrenwutouxiang.glb'
       
   //      let res;
		

		var baseComponent = new THREE.Object3D();
         loader.load('http://localhost:23333/video/shuiliushiyan.gltf', function ( gltf ) {
             //var coneMesh;
             //coneMesh = new THREE.Mesh( gltf.scene.children[ 0 ].geometry, gltfmaterial );
             // //coneMesh.position = this.position;
             // //coneMesh.scale.setScalar( 100 );
             // console.log(coneMesh);
             // gltf.scene.translateY(1000);
             // scene.add(gltf.scene);
             //scene.add(coneMesh);

             const root = gltf.scene;
			//root.children[2].material = new THREE.MeshBasicMaterial({color:0xff0000});
			root.children.forEach(element => {
				if (element.type == "Mesh") {
					element.material.emissive = element.material.color;
					element.material.emissiveMap = element.material.map;
				}
			});
                
			// // });
			var res = root.children[2];
			baseComponent.add(res);
			scene.add(baseComponent);
			//var mixer = new THREE.AnimationMixer( res );
			//mixer.clipAction( gltf.animations[ 0 ] ).setDuration( 1 ).play();
			//mixers.push( mixer );

           
		} );
		baseComponent.position.set(0,0,0);
		baseComponent.scale.set(5,5,5);
		
        var cubeGeo1 = new THREE.CubeGeometry(20, 20, 20, 5, 5, 5);//创建立方体
        var cubeMat1 = new THREE.MeshLambertMaterial({//创建材料
            color:0x003300,
            wireframe:false
        });
        cubeMesh1 = new THREE.Mesh(cubeGeo1, cubeMat1);//创建立方体网格模型
        cubeMesh1.position.set(20, 10, 0);
        cubeMesh1.name = "asd"
        var base = new THREE.Object3D();
        base.add(cubeMesh1);
        for (var i = base.children.length - 1; i >= 0; i--) {
            base.remove(base.children[i]);
        }
        scene.add(base);


        var cubeGeo2 = new THREE.CubeGeometry(20, 20, 20, 5, 5, 5);//创建立方体
        var cubeMat2 = new THREE.MeshLambertMaterial({//创建材料
            color:0x880000,
            wireframe:false
        });
        cubeMesh2 = new THREE.Mesh(cubeGeo2, cubeMat2);//创建立方体网格模型
        cubeMesh2.position.set(-20, 1, 0);
        scene.add(cubeMesh2);


        var cubeGeo3 = new THREE.CubeGeometry(20, 20, 20, 5, 5, 5);//创建立方体
        var cubeMat3 = new THREE.MeshLambertMaterial({//创建材料
            color:0x000099,
            wireframe:false
        });
        cubeMesh3 = new THREE.Mesh(cubeGeo3, cubeMat3);//创建立方体网格模型
        cubeMesh3.position.set(20, -10, 0);
        scene.add(cubeMesh3);


        document.addEventListener( 'mousemove', onDocumentMouseMove, false );

				//

        //window.addEventListener( 'resize', onWindowResize, false );
        //console.log(res);
        removeLoading();

        // var fbx_loader = new FBXLoader();
        // fbx_loader.load('http://localhost:8080/video/building.fbx', function(object) {
        //     object.scale.multiplyScalar(.1);    // 缩放模型大小
        //     scene.add(object);
        // });

        // var mtlLoader = new MTLLoader();
        // // mtlLoader.setPath('/lib/assets/models/');
        // //加载mtl文件
        // mtlLoader.load('http://localhost:8080/video/building.mtl', function (material) {
        //     var objLoader = new OBJLoader();
        //     //设置当前加载的纹理
        //     objLoader.setMaterials(material);
        
        //     objLoader.load('http://localhost:8080/video/building.obj', function (object) {

        //         // //获取两个翅膀的位置
        //         // var wing2 = object.children[5];
        //         // var wing1 = object.children[4];

        //         // //设置两个翅膀的透明度
        //         // wing1.material.opacity = 0.6;
        //         // wing1.material.transparent = true;
        //         // wing1.material.depthTest = false;
        //         // wing1.material.side = THREE.DoubleSide;

        //         // wing2.material.opacity = 0.6;
        //         // wing2.material.depthTest = false;
        //         // wing2.material.transparent = true;
        //         // wing2.material.side = THREE.DoubleSide;
        //         console.log(object);
        //         //将模型缩放并添加到场景当中
        //         object.scale.set(100, 100, 100);
        //         scene.add(object);
        //     })
        // });
    }

    /* 移除加载元素 */
    function removeLoading() {

        document.getElementById('loading').style.display = 'none';

    }

    /* 性能插件 */
    function initStats() {

        var stats = new Stats();

        document.body.appendChild(stats.domElement);

        return stats;

    }


    function onDocumentMouseMove( event ) {

        event.preventDefault();

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

    }
    /* 窗口变动触发 */
    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        //renderer.setSize(window.innerWidth, window.innerHeight);

    }

    /* 数据更新 */
    function update() {

        stats.update();
        controls.update();

        // 设置纹理偏移
        // texture_left.offset.x -= 0.02;
        //texture_up.offset.y -= 0.008;


    }

    /* 初始化 */
    function init() {

        initScene();
        initCamera();
        initRender();
        initLight();
        initControls();
        initContent();
        initGui();
        /* 监听事件 */
        //window.addEventListener('resize', onWindowResize, false);

    }

    /* 循环渲染 */
    function animate() {

        // if ( materialShader ) {

        //     materialShader.uniforms.time.value = performance.now() / 1000;

        // }   
        //camera.updateMatrixWorld();

        // find intersections
        //console.log(camera.position);
		
		var delta = clock.getDelta();
		for ( var i = 0; i < mixers.length; i ++ ) { // 重复播放动画
			mixers[ i ].update( delta );
		}
        raycaster.setFromCamera( mouse, camera );
        

        var intersects = raycaster.intersectObjects( [cubeMesh1, cubeMesh2, cubeMesh3] );

        if ( intersects.length > 0 ) {

            if ( INTERSECTED != intersects[ 0 ].object ) {

                if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

                INTERSECTED = intersects[ 0 ].object;
                INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                INTERSECTED.material.emissive.setHex( 0xff0000 );

            }

        } else {

            if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

            INTERSECTED = null;

        }
        
        requestAnimationFrame(animate);
        
        renderer.render(scene, camera);
        update();

    }

    /* 初始加载 */
    (function () {
        init();
        animate();
    })();

</script>
</body>
</html>

